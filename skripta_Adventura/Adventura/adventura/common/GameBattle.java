package common;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.function.Function;

/**
 * Class representing a battle
 *
 * @author Denis Akopyan
 * @version 1.0
 */
public class GameBattle {
  private static final Random numberGenerator = new Random();
  
  private int currentSolution;
  private boolean defeated;
  private int hits;
  private final int rounds;
  private final int parameters;
  private final String problemFormat;
  private final Function<List<Integer>, Integer> problemGenerator;
  
  /**
   * Getter for the CurrentSolution property
   *
   * @return current attack solution value
   */
  public int getCurrentSolution() {
    return currentSolution;
  }
  
  /**
   * Determines whether the current battle is defeated
   *
   * @return is the current battle defeated
   */
  public boolean isDefeated() {
    return defeated;
  }
  
  /**
   * Default constructor
   *
   * @param rounds battle rounds
   * @param parameters problem variables count
   * @param problemFormat problem format
   * @param problemGenerator problem variable values generator
   * @implNote the parameters parameter defines how many variables must be formatted by the problemFormat and values generated by the problemGenerator
   */
  public GameBattle(int rounds, int parameters, String problemFormat, Function<List<Integer>, Integer> problemGenerator) {
    this.rounds = rounds;
    this.parameters = parameters;
    this.problemFormat = problemFormat;
    this.problemGenerator = problemGenerator;
  }
  
  /**
   * Attempt to defend against the current attack
   *
   * @param input defence value
   * @return true if defense was successful
   */
  public boolean defend(int input) {
    // Check whether the defence matches the solution
    var result = input == currentSolution;
    // If the defence was a success the given number of times..
    if (result && ++hits == rounds)
      // the battle is won
      defeated = true;
    
    // return defence success state
    return result;
  }
  
  /**
   * Generates the problem and the expected result
   *
   * @return tuple of the problem format and expected result
   */
  public String nextAttack() {
    // Prepare the parameters collection
    var parameters = new ArrayList<Integer>();
    // For the number of required parameters..
    for (int i = 0; i < this.parameters; i++)
      // populate the parameters with a random number
      parameters.add(numberGenerator.nextInt(50));
    
    // Get the current problem solution
    currentSolution = problemGenerator.apply(parameters);
    
    // Materialize the result
    return StringHelper.format(problemFormat, parameters.toArray());
  }
}
